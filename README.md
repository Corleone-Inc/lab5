# lab5

# Лабораторная работа 5
## SAST
### Анализ инструментом Fortify
Результаты сканирования:
<img width="2556" height="1386" alt="Screenshot 2025-12-14 214809" src="https://github.com/user-attachments/assets/48f0e6c6-a162-4347-896e-63a578087765" />
Отчет по уязвимости:
Тип уязвимости: Хардкодинг (жёсткая привязка) криптографического ключа
Instance ID: 51DD573C9D1FF439DECD37FE4F612F52  
#### 1. Суть уязвимости
В коде приложения используется жёстко заданный (hardcoded) ключ шифрования, то есть значение ключа напрямую указано в исходном коде как строковая или байтовая константа.
```python
from Crypto.Ciphers import AES
encryption_key = b'_hardcoded__key_'
cipher = AES.new(encryption_key, AES.MODE_CFB, iv)
msg = iv + cipher.encrypt(b'Attack at dawn')
```
#### 2. Потенциальная опасность
- Раскрытие ключа: Любой, у кого есть доступ к исходному коду (разработчики, стажёры, злоумышленник при утечке кода), сразу получает доступ к ключу шифрования.
- Затруднённое исправление: После развёртывания приложения в продакшене изменение ключа возможно только через обновление кода и повторное развёртывание, что может быть технически сложно и дорого.
- Риск компрометации данных: Если ключ становится известен злоумышленнику, он может:
	- Расшифровать все ранее зашифрованные данные.
	- Подделать или подменить зашифрованные сообщения.
- Нарушение принципов безопасного хранения секретов: Ключи шифрования должны храниться вне исходного кода, в защищённых хранилищах (например, HashiCorp Vault, AWS Secrets Manager, переменные окружения с ограничением доступа и т.д.).
#### 3. Оценка риска (по данным Forify)
<table>
    <tr>
        <th>Параметр</th>
        <th>Значение</th>
    </tr>
    <tr>
        <td>Impact (Последствия)</td>
        <td>3.0/5.0</td>
    </tr>
    <tr>
        <td>Likelihood (Вероятность эксплуатации)</td>
        <td>2.4/5.0</td>
    </tr>
    <tr>
        <td>Severity (Общая серьезность)</td>
        <td>4.0/5.0</td>
    </tr>
    <tr>
        <td>Confidence (Уверенность в обнаружении)</td>
        <td>5.0/5.0</td>
    </tr>
</table>
Согласно Fortify, эта критическая уязвимость может привести к серьезным последствиям при компрометации.

#### 4. Рекомендации по устранению
- Удалить хардкодированный ключ из исходного кода.
- Хранить ключи шифрования в безопасных внешних источниках, например:
	- Переменные окружения (с ограничением доступа на уровне ОС/контейнера).
	- Специализированные хранилища секретов: AWS Secrets Manager, Azure Key Vault, HashiCorp Vault.
	- Зашифрованные конфигурационные файлы с контролем доступа.
- Ограничить доступ к хранилищу ключей только тем компонентам системы, которые действительно должны их использовать.
- Реализовать механизм ротации ключей, чтобы в случае компрометации можно было легко заменить ключ без изменения кода.
- Провести аудит всего кода на предмет других хардкодированных секретов (паролей, токенов, API-ключей и т.д.).
### Анализ инструментом Bandit
Сводка по выявленным уязвимостям:
<table>
    <tr>
        <th>Уровень серьезности</th>
        <th>Количество</th>
    </tr>
    <tr>
        <td>High</td>
        <td>2</td>
    </tr>
    <tr>
        <td>Medium</td>
        <td>4</td>
    </tr>
    <tr>
        <td>Low</td>
        <td>3</td>
    </tr>
</table>

1. CWE-502: Deserialization of Untrusted Data
- Bandit ID: `B403` (импорт `pickle`) + `B301` (вызов `pickle.loads`)  
- Строки: 7, 166  
- Серьёзность: Low (B403), Medium (B301)  
- Уверенность: High
Модуль `pickle` в Python небезопасен при десериализации данных из недоверенного источника. Злоумышленник может создать специально сформированный pickle-объект, при десериализации которого будет выполнено произвольное Python-код.
Пример из кода:
```python
data = pickle.loads(bytes.fromhex(user_data))
```
Здесь `user_data` поступает от пользователя и никак не проверяется. Таким образом, появляется риск выполнения произвольного кода на сервере и полной компрометации приложения. Во избежании таких проблем не нужно использовать `pickle` для обмена с внешними системами и пользователями, также следуюет использовать безопасные форматы: JSON, XML и т.д. Если же `pickle` критически необходим можно применить подписи или шифрование + аутентификацию данных, и никогда не десериализировать без доверенного источника.
2. CWE-78: OS Command Injection
- Bandit ID: B404 (импорт `subprocess`) + B602 (использование `shell=True`)  
- Строки: 8, 185  
- Серьёзность: Low (B404), High (B602)  
- Уверенность: High
Код использует `subprocess.check_output(..., shell=True)` с непроверенными пользовательскими данными, что открывает путь для инъекции команд ОС.
Пример из кода:
```python
result = subprocess.check_output(f"ping -c 1 {host}", shell=True, text=True)
```
Если host содержит, например: `8.8.8.8; rm -rf /`, то команда `rm -rf /` будет выполнена.
Риски: удаление файлов, запуск вредоносных процессов, кража данных, вероятность полного захвата сервера.
Рекомендации: 
- Никогда не использовать shell=True с данными от пользователя  
- Передавать аргументы в виде списка
- Валидировать host как доменное имя или IP-адрес (регулярные выражения, allowlist)
- Ограничить права процесса (principle of least privilege)
3. CWE-259: Hardcoded Password / Secret
- Bandit ID: B105  
- Строка: 12  
- Серьёзность: Low  
- Уверенность: Medium
Секретный ключ Flask задан как строковая константа: `app.secret_key = 'supersecretkey'`
Риск: любой, у кого есть доступ к коду (включая репозиторий), знает ключ сессий, возможна подделка сессий, аутентификационных токенов и т.д.
Рекомендации:
- Загружать ключ из переменной окружения или защищённого хранилища секретов
- Использовать криптографически стойкие ключи (32+ байта случайных данных)
4. CWE-89: SQL Injection
- Bandit ID: B608  
- Строка: 43  
- Серьёзность: Medium  
- Уверенность: Low
SQL-запрос формируется через конкатенацию строк с пользовательским вводом:
```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```
Риски:
- Обход аутентификации (например, ввод admin'--)  
- Чтение/изменение/удаление любых данных в БД  
- В некоторых СУБД — выполнение ОС-команд (например, xp_cmdshell в MS SQL)
Рекомендации:
- Использовать параметризованные запросы
- Никогда не сравнивать пароли напрямую в SQL — хранить хэши (bcrypt, Argon2) и проверять их в коде
5. CWE-400: Uncontrolled Resource Consumption (Missing Timeout)
- Bandit ID: B113  
- Строка: 206  
- Серьёзность: Medium  
- Уверенность: Low
Вызов `requests.get(url)` без таймаута:
```python
response = requests.get(url)
```
Риски:
- Возможность DoS-атаки: внешний сервер может «зависнуть» и удерживать соединение  
- Исчерпание пула соединений, потоков или памяти
Рекомендации: всегда указывать таймаут
6. CWE-94: Code Injection via Debug Mode (Flask)
- Bandit ID: B201  
- Строка: 256  
- Серьёзность: High  
- Уверенность: Medium
Приложение запускается с debug=True:
```python
app.run(debug=True, host='0.0.0.0', port=5000)
```
Риски:
- Werkzeug debugger позволяет выполнять произвольный Python-код через веб-интерфейс  
- При публичной доступности (особенно на 0.0.0.0) — мгновенный компромет
Рекомендации:
- Всегда отключать debug=True в продакшене  
- Использовать переменные окружения
7. CWE-605: Binding to All Interfaces
- Bandit ID: B104  
- Строка: 256  
- Серьёзность: Medium  
- Уверенность: Medium
Сервер слушает на всех интерфейсах: `host='0.0.0.0'`
Риски:
- Приложение доступно извне, даже если предназначено только для локального использования  
- Увеличивает поверхность атаки
Рекомендации:
- В разработке: host='127.0.0.1'  
- В продакшене: использовать обратный прокси (Nginx), а не прямой запуск Flask на публичном IP  
- Контролировать доступ через firewall
В заключении, можно составить следующий рекомендуемый порядок действий:
1. Убрать debug=True и host='0.0.0.0'
2. Заменить subprocess с shell=True на безопасный вызов без shell
3. Устранить использование pickle для пользовательских данных
4. Перейти на параметризованные SQL-запросы
5. Внедрить безопасное управление секретами и таймаутами
